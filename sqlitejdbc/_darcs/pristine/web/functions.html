<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="/content.css" />
    <link rel="stylesheet" type="text/css" href="/javasource.css" />
    <title>SQLiteJDBC - Custom Functions</title>
</head>
<body>
<div class="ad">
<script type="text/javascript"><!--
google_ad_client = "pub-3074710994457921";
google_ad_width = 120;
google_ad_height = 240;
google_ad_format = "120x240_as";
google_ad_type = "text";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>



<div class="content">
<h1>SQLiteJDBC</h1>

<p class="item">
    <a href="../">&#60;-</a> |
    <a href="index.html">SQLiteJDBC</a> |
    <a href="changes.html">Changelog</a> |
    <a href="usage.html">Usage</a> |
    <a href="speed.html">Speed</a> |
    <a href="functions.html">Custom Functions</a> |
    <a href="api/">Javadoc</a>
</p>

<h2>Custom Functions</h2>

<p>As of v018, SQLiteJDBC now provides a custom interface for
creating custom functions accessible inside SQLite, written in
Java.</p>

<p>All you have to do is subclass
<a href="api/index.html"><tt>org.sqlite.Function</tt></a> and
implement <tt>xFunc()</tt>. Pass the new instance to
<tt>Function.create()</tt> and SQLite is ready to call it.</p>

<h3>Basic Example</h3>

<pre class="code" id="Classes">
<font id="Import">import</font> java.sql.*;
<font id="Import">import</font> org.sqlite.Function;

<font id="Public">public</font> <font id="Class">class</font> Test {
    <font id="Public">public</font> <font id="Static">static</font> <font id="Void">void</font> main(String[] args) {
        Class.forName(<font id="StringLiteral">"org.sqlite.JDBC"</font>);
        Connection conn = DriverManager.getConnection(<font id="StringLiteral">"jdbc:sqlite:"</font>);

        Function.create(conn, <font id="StringLiteral">"myFunc"</font>, <font id="New">new</font> Function() {
            <font id="Public">protected</font> <font id="Void">void</font> xFunc() <font id="Throws">throws</font> SQLException {
                System.out.println(<font id="StringLiteral">"myFunc called!"</font>);
            }
        });

        conn.createStatement().execute(<font id="StringLiteral">"select myFunc();"</font>);
        conn.close();
    }
}
</pre>

<h3>Aggregate Functions</h3>

<p>By subclassing <tt>Function.Aggregate</tt> and implementing <tt>xStep()</tt>
and <tt>xFinal()</tt> you can create an aggregate function. E.g.</p>

<pre class="code" id="Classes">
    Class.forName(<font id="StringLiteral">"org.sqlite.JDBC"</font>);
    Connection conn = DriverManager.getConnection(<font id="StringLiteral">"jdbc:sqlite:"</font>);

    Function.create(conn, <font id="StringLiteral">"mySum"</font>, <font id="New">new</font> Function.Aggregate() {
        <font id="Private">private</font> <font id="Int">int</font> sum = <font id="IntegerLiteral">0</font>;
        <font id="Public">protected</font> <font id="Void">void</font> xStep() <font id="Throws">throws</font> SQLException {
            sum += value_int(<font id="IntegerLiteral">0</font>);
        }
        <font id="Public">protected</font> <font id="Void">void</font> xFinal() <font id="Throws">throws</font> SQLException {
            result(sum);
        }
    });

    Statement stat = conn.createStatement();
    stat.executeUpdate(<font id="StringLiteral">"create table t1 (c1);"</font>);
    stat.executeUpdate(<font id="StringLiteral">"insert into t1 values (2);"</font>);
    stat.executeUpdate(<font id="StringLiteral">"insert into t1 values (4);"</font>);
    stat.executeUpdate(<font id="StringLiteral">"insert into t1 values (3);"</font>);
    ResultSet rs = stat.executeQuery(<font id="StringLiteral">"select mySum(c1) from t1;"</font>);
    rs.next();
    System.out.println(<font id="StringLiteral">"mySum = "</font> + rs.getInt(1));
</pre>

<p>Prints <tt>mySum = 9</tt>. It is safe to use internal variables as
every time an aggregate function is called it is <tt>clone()</tt>ed to
ensure thread safety.</p>

<h3>Triggers</h3>

<p>The most interesting use of custom functions are making SQLite triggers.
This way your Java application can be informed of changes in your tables.</p>

<pre class="code" id="Classes">
<font id="Import">import</font> java.sql.*;
<font id="Import">import</font> org.sqlite.Function;

<font id="Public">public</font> <font id="Class">class</font> Test {
    <font id="Public">public</font> <font id="Static">static</font> <font id="Void">void</font> main(String[] args) {
        Class.forName(<font id="StringLiteral">"org.sqlite.JDBC"</font>);
        Connection conn = DriverManager.getConnection(<font id="StringLiteral">"jdbc:sqlite:"</font>);

        Function.create(conn, <font id="StringLiteral">"myFunc"</font>, <font id="New">new</font> Function() {
            <font id="Public">protected</font> <font id="Void">void</font> xFunc() {
                System.out.println(<font id="StringLiteral">"database updated"</font>);
            }
        });

        Statement stat = conn.createStatement();
        stat.executeUpdate(<font id="StringLiteral">"create table table1 (col1, col2);"</font>);
        stat.executeUpdate(
            <font id="StringLiteral">"create trigger trig1 after insert on table1 begin"</font> +
            <font id="StringLiteral">"    select callTrig();"</font> +
            <font id="StringLiteral">"end;"</font>
        );

        stat.executeUpdate(<font id="StringLiteral">"insert into table1 values (1, 2);"</font>);
        conn.close();
    }
}
</pre>

<h3>Arguments and Results</h3>

<p>The protected functions <tt>value_&lt;type&gt;(int)</tt>,
<tt>result(&lt;type&gt;)</tt> of
<a href="api/index.html">org.sqlite.Function</a> provide access
to arguments and the ability to return a value.</p>

<pre class="code" id="Classes">
    Function.create(conn, <font id="StringLiteral">"mySum"</font>, <font id="New">new</font> Function() {
        <font id="Public">protected</font> <font id="Void">void</font> xFunc() <font id="Throws">throws</font> SQLException {
            int s = 0;
            for (int i=0; i &lt; arg(); i++)
                s += value_int(i);
            result(s);
        }
    });

    ResultSet rs = conn.createStatement().execute(
        <font id="StringLiteral">"select mySum(1, 3, 5);"</font>);
    rs.next();

    System.out.println(rs.getInt(1));
</pre>

<p>Prints <tt>9</tt>.</p>

</div>
<p class="sig">2006-08-22</p>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
    _uacct = "UA-2989140-1";
    urchinTracker();
</script>
</body>
</html>
